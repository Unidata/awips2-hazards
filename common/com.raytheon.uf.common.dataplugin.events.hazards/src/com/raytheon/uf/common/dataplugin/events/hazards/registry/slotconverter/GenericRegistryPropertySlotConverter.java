/**
 * This software was developed and / or modified by the
 * National Oceanic and Atmospheric Administration (NOAA), 
 * Earth System Research Laboratory (ESRL), 
 * Global Systems Division (GSD), 
 * Evaluation & Decision Support Branch (EDS)
 * 
 * Address: Department of Commerce Boulder Labs, 325 Broadway, Boulder, CO 80305
 */
package com.raytheon.uf.common.dataplugin.events.hazards.registry.slotconverter;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;

import com.raytheon.uf.common.dataplugin.events.hazards.HazardConstants;
import com.raytheon.uf.common.registry.ebxml.slots.SlotConverter;

import gov.noaa.gsd.common.utilities.geometry.IAdvancedGeometry;
import oasis.names.tc.ebxml.regrep.xsd.rim.v4.BooleanValueType;
import oasis.names.tc.ebxml.regrep.xsd.rim.v4.FloatValueType;
import oasis.names.tc.ebxml.regrep.xsd.rim.v4.IntegerValueType;
import oasis.names.tc.ebxml.regrep.xsd.rim.v4.SlotType;
import oasis.names.tc.ebxml.regrep.xsd.rim.v4.StringValueType;
import oasis.names.tc.ebxml.regrep.xsd.rim.v4.ValueType;

/**
 * Description: Slot converter used to "flatten" maps of property names to their
 * values so that each such property occupies a different slot, with the slot
 * name being a combination of the provided slot name and the name of that
 * property. Furthermore, any property values that are collections are
 * themselves flattened, so that each of their elements occupies a different
 * slot.
 * <p>
 * Note that each slot created have as its slot name the string
 * {@link HazardConstants#GENERIC_PROPERTY}, followed by a hyphen (
 * "<code>-</code>"), followed by the name of the property. The slot name as
 * passed into {@link #getSlots(String, Object)} is ignored.
 * </p>
 * <p>
 * Note also that each element must be either one of the object wrappers for
 * Java primitives (integers, booleans, etc.), a {@link String}, a {@link Date},
 * an {@link IAdvancedGeometry}, or a collection that itself holds zero or more
 * of the above. Any element that is an instance of any other class will be
 * converted to its slot value using its {@link Object#toString()} method.
 * </p>
 * 
 * <pre>
 * 
 * SOFTWARE HISTORY
 * Date         Ticket#    Engineer     Description
 * ------------ ---------- ------------ --------------------------
 * Oct 02, 2017   38506    Chris.Golden Initial creation.
 * </pre>
 * 
 * @author Chris.Golden
 * @version 1.0
 */
public class GenericRegistryPropertySlotConverter implements SlotConverter {

    // Public Static Methods

    /**
     * Get the prefix to be used for the name of the slot with the specified
     * property name generated by this class.
     *
     * @param name
     *            Property name for which to generate the slot name prefix.
     * @return Prefix to be used for the name of the slot.
     */
    public static String getSlotNamePrefixForPropertyName(String name) {
        return (HazardConstants.UNIQUE_ID.equals(name) ? ""
                : HazardConstants.GENERIC_PROPERTY + "-");
    }

    // Public Methods

    /**
     * Create a list of slot types from the specified value.
     * 
     * @param slotName
     *            Ignored in this implementation.
     * @param slotValue
     *            Value for which to generate slots; must be a {@link Map}.
     * @throws IllegalArgumentException
     *             If the <code>slotValue</code> is not a <code>Map</code>.
     */
    @Override
    public List<SlotType> getSlots(String slotName, Object slotValue)
            throws IllegalArgumentException {

        /*
         * Ensure the value is a map.
         */
        if (slotValue instanceof Map == false) {
            throw new IllegalArgumentException("Object of type "
                    + slotValue.getClass().getName()
                    + " cannot be converted by " + getClass().getName());
        }

        /*
         * Iterate through the pairings within the map, creating slots for each.
         * The slot name for each is a concatenation of the slot name provided
         * by the caller and the key for that entry.
         */
        Map<?, ?> map = (Map<?, ?>) slotValue;
        List<SlotType> slots = new ArrayList<SlotType>(map.size());
        for (Map.Entry<?, ?> entry : map.entrySet()) {

            /*
             * If the value of the entry is a collection, add a slot for each
             * element within the collection; otherwise, simply add a single
             * slot for the entry value.
             */
            if (entry.getValue() instanceof Collection) {
                for (Object element : (Collection<?>) entry.getValue()) {
                    slots.add(new SlotType(slotName + "-" + entry.getKey(),
                            getValueType(element)));
                }
            } else {
                slots.add(new SlotType(
                        getSlotNamePrefixForPropertyName(
                                entry.getKey().toString()) + entry.getKey(),
                        getValueType(entry.getValue())));
            }
        }

        return slots;
    }

    // Private Methods

    /**
     * Get the value type for the given value.
     * 
     * @param value
     *            Value for which to fetch the value type.
     * @return Value type.
     */
    private ValueType getValueType(Object value) {
        ValueType retVal = null;
        if (value == null) {
            retVal = new StringValueType("");
        } else if (value instanceof String) {
            retVal = new StringValueType((String) value);
        } else if (value instanceof Boolean) {
            retVal = new BooleanValueType((Boolean) value);
        } else if (value instanceof Date) {
            retVal = new IntegerValueType(new BigInteger(
                    String.valueOf(((Date) value).getTime()).trim()));
        } else if (value instanceof Float) {
            retVal = new FloatValueType(((Float) value).floatValue());
        } else if (value instanceof Double) {
            retVal = new FloatValueType(((Double) value).floatValue());
        } else if (value instanceof Long) {
            retVal = new IntegerValueType(
                    new BigInteger(String.valueOf(value)));
        } else if (value instanceof Integer) {
            retVal = new IntegerValueType((Integer) value);
        } else {
            retVal = new StringValueType(value.toString());
        }
        return retVal;
    }
}
