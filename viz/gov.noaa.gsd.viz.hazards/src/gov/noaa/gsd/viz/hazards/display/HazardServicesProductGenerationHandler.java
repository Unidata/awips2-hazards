/**
 * This software was developed and / or modified by the
 * National Oceanic and Atmospheric Administration (NOAA), 
 * Earth System Research Laboratory (ESRL), 
 * Global Systems Division (GSD), 
 * Information Services Branch (ISB)
 * 
 * Address: Department of Commerce Boulder Labs, 325 Broadway, Boulder, CO 80305
 */
package gov.noaa.gsd.viz.hazards.display;

import gov.noaa.gsd.common.eventbus.BoundedReceptionEventBus;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import net.engio.mbassy.listener.Handler;

import org.apache.commons.lang.builder.ToStringBuilder;

import com.raytheon.uf.common.dataplugin.events.EventSet;
import com.raytheon.uf.common.dataplugin.events.IEvent;
import com.raytheon.uf.common.dataplugin.events.hazards.event.HazardEvent;
import com.raytheon.uf.common.dataplugin.events.hazards.event.IHazardEvent;
import com.raytheon.uf.common.hazards.productgen.GeneratedProductList;
import com.raytheon.uf.common.hazards.productgen.KeyInfo;
import com.raytheon.uf.common.hazards.productgen.data.ProductData;
import com.raytheon.uf.common.status.IUFStatusHandler;
import com.raytheon.uf.common.status.UFStatus;
import com.raytheon.uf.viz.hazards.sessionmanager.ISessionManager;
import com.raytheon.uf.viz.hazards.sessionmanager.events.impl.ObservedHazardEvent;
import com.raytheon.uf.viz.hazards.sessionmanager.product.IProductGenerationComplete;
import com.raytheon.uf.viz.hazards.sessionmanager.product.ISessionProductManager;
import com.raytheon.uf.viz.hazards.sessionmanager.product.ProductFailed;
import com.raytheon.uf.viz.hazards.sessionmanager.product.ProductGenerated;
import com.raytheon.uf.viz.hazards.sessionmanager.product.ProductGenerationComplete;
import com.raytheon.uf.viz.hazards.sessionmanager.product.ProductInformation;
import com.raytheon.uf.viz.hazards.sessionmanager.product.ProductStagingInfo;
import com.raytheon.uf.viz.hazards.sessionmanager.product.ProductStagingInfo.Product;

/**
 * Description: Handles products generated by the Product Generation Framework.
 * TODO It seems wrong to have a separate class in this plugin to do product
 * generation handling. Ideally the {@link ISessionProductManager} should have
 * this functionality. But the current road block is that this code references
 * several other classes that are in this plugin. Do we figure out a way to move
 * the other classes into {@link ISessionProductManager}s plugin?
 * 
 * <pre>
 * 
 * SOFTWARE HISTORY
 * Date         Ticket#    Engineer    Description
 * ------------ ---------- ----------- --------------------------
 * Nov 15, 2013    2182    daniel.s.schaffer@noaa.gov      Initial creation
 * Nov 21, 2013  2446      daniel.s.schaffer@noaa.gov Bug fixes in product staging dialog
 * Dec 3, 2013   1472      bkowal      subtype field is now subType
 * 
 * Dec 03, 2013 2182 daniel.s.schaffer@noaa.gov Refactoring - Update for move of JSONConverter
 * Feb 07, 2014 2890       bkowal      Product Generation JSON refactor.
 * Apr 29, 2014 3558       bkowal      Halt product generation if the user clicks "No" on the confirm issue dialog.
 * Apr 23, 2014 1480       jsanchez    Added a generateReviewableProduct method.
 * Sep 09, 2014 4042       Chris.Golden Relocated method for building product staging info to
 *                                      the product staging presenter where it belonged.
 * </pre>
 * 
 * @author daniel.s.schaffer@noaa.gov
 * @version 1.0
 */
class HazardServicesProductGenerationHandler {

    private final transient IUFStatusHandler statusHandler = UFStatus
            .getHandler(this.getClass());

    private final ISessionManager<ObservedHazardEvent> sessionManager;

    private final ISessionProductManager productManager;

    private final Map<String, ProductGenerationAuditor> productGenerationAuditManager;

    private final BoundedReceptionEventBus<Object> eventBus;

    private final HazardServicesAppBuilder appBuilder;

    private final Map<Boolean, Collection<ProductInformation>> selectedProductsCache;

    HazardServicesProductGenerationHandler(
            ISessionManager<ObservedHazardEvent> sessionManager,
            HazardServicesAppBuilder appBuilder) {
        this.sessionManager = sessionManager;
        this.productManager = sessionManager.getProductManager();
        this.appBuilder = appBuilder;
        this.eventBus = appBuilder.getEventBus();
        this.productGenerationAuditManager = new HashMap<String, ProductGenerationAuditor>();

        this.eventBus.subscribe(this);
        selectedProductsCache = new HashMap<>();
    }

    boolean productGenerationRequired(boolean issue) {
        boolean result = true;
        Collection<ProductInformation> products = productManager
                .getSelectedProducts(issue);
        selectedProductsCache.put(issue, products);
        for (ProductInformation info : products) {
            if (info.getDialogInfo() != null && !info.getDialogInfo().isEmpty()) {
                result = false;
            } else if (info.getPossibleProductEvents() != null
                    && !info.getPossibleProductEvents().isEmpty()) {
                result = false;
            }
            if (!result) {
                break;
            }
        }
        return result;
    }

    public void generateProducts(boolean issue) {
        this.runProductGeneration(selectedProductsCache.get(issue), issue);
    }

    public void generateReviewableProduct(List<ProductData> result) {
        ProductInformation productInformation = new ProductInformation();
        synchronized (this.productGenerationAuditManager) {
            final String productGenerationTrackingID = UUID.randomUUID()
                    .toString();
            ProductGenerationAuditor productGenerationAuditor = new ProductGenerationAuditor(
                    false, productGenerationTrackingID);
            productInformation.setGenerationID(productGenerationTrackingID);
            productGenerationAuditor
                    .addProductToBeGenerated(productInformation);
            this.productGenerationAuditManager.put(productGenerationTrackingID,
                    productGenerationAuditor);
        }

        if (result.isEmpty() == false) {
            List<LinkedHashMap<KeyInfo, Serializable>> updatedDataList = new ArrayList<LinkedHashMap<KeyInfo, Serializable>>();
            EventSet<IEvent> eventSet = new EventSet<IEvent>();
            for (ProductData productData : result) {

                updatedDataList.add(productData.getData());

                if (productInformation.getProductGeneratorName() == null) {
                    String productGeneratorName = productData
                            .getProductGeneratorName();
                    productInformation
                            .setProductGeneratorName(productGeneratorName);
                    productInformation.setProductFormats(sessionManager
                            .getConfigurationManager()
                            .getProductGeneratorTable()
                            .getProductFormats(productGeneratorName));

                    for (Integer eventID : productData.getEventIDs()) {
                        IHazardEvent hazardEvent = new HazardEvent();
                        hazardEvent.setStartTime(productData.getStartTime());
                        hazardEvent.setEventID(String.valueOf(eventID));
                        eventSet.add(hazardEvent);
                    }

                    GeneratedProductList products = new GeneratedProductList();
                    products.setEventSet(eventSet);
                    productInformation.setProducts(products);
                }
            }

            this.productManager.generateProductReview(productInformation,
                    updatedDataList);
        }

    }

    /**
     * createProductsFromHazardEventSets -- Generate products from Hazard Event
     * Sets created from the Product Staging Dialog or by the previous method,
     * "createProductsFromEventIDs"
     * 
     * @param issueFlag
     *            -- if True, issue the results
     * @param hazardEventSets
     * 
     */
    public void createProductsFromHazardEventSets(boolean issue,
            List<GeneratedProductList> generatedProductsList) {
        Collection<ProductInformation> selectedProducts = productManager
                .getSelectedProducts(issue);

        selectedProductsCache.put(issue, selectedProducts);

        ProductInformation productInformation = null;

        Collection<ProductInformation> productsToGenerate = new ArrayList<ProductInformation>();

        List<String> selectedEventIDs = new ArrayList<>();
        for (ObservedHazardEvent selectedEvent : this.sessionManager
                .getEventManager().getSelectedEvents()) {
            selectedEventIDs.add(selectedEvent.getEventID());
        }

        for (GeneratedProductList productList : generatedProductsList) {
            for (ProductInformation selectedProductInformation : selectedProducts) {
                if (productList.getProductInfo().equals(
                        selectedProductInformation.getProductGeneratorName())) {
                    productInformation = selectedProductInformation;
                    break;
                }
            }

            Set<IHazardEvent> selectedEvents = new HashSet<IHazardEvent>();
            for (IHazardEvent hazardEvent : productInformation
                    .getProductEvents()) {
                if (selectedEventIDs.contains(hazardEvent.getEventID())) {
                    selectedEvents.add(hazardEvent);
                }
            }
            for (IHazardEvent hazardEvent : productInformation
                    .getPossibleProductEvents()) {
                if (selectedEventIDs.contains(hazardEvent.getEventID())) {

                    selectedEvents.add(hazardEvent);
                }
            }

            productInformation.setProductEvents(selectedEvents);
            productsToGenerate.add(productInformation);
        }

        this.runProductGeneration(productsToGenerate, issue);
    }

    public void createProductsFromProductStagingInfo(boolean issue,
            ProductStagingInfo productStagingInfo) {
        Collection<ProductInformation> products = selectedProductsCache
                .get(issue);

        Collection<ProductInformation> productsToGenerate = new ArrayList<ProductInformation>();

        for (Product stagedProduct : productStagingInfo.getProducts()) {
            for (ProductInformation product : products) {
                if (stagedProduct.getProductGenerator().equals(
                        product.getProductGeneratorName())) {

                    Set<IHazardEvent> selectedEvents = new HashSet<IHazardEvent>();
                    for (String eventID : stagedProduct.getSelectedEventIDs()) {
                        for (IHazardEvent event : product.getProductEvents()) {
                            if (event.getEventID().equals(eventID)) {
                                selectedEvents.add(event);
                                break;
                            }
                        }
                        for (IHazardEvent event : product
                                .getPossibleProductEvents()) {
                            if (event.getEventID().equals(eventID)) {
                                selectedEvents.add(event);
                                break;
                            }
                        }
                    }
                    product.setProductEvents(selectedEvents);
                    product.setDialogSelections(stagedProduct
                            .getDialogSelections());
                    productsToGenerate.add(product);
                }
            }
        }
        this.runProductGeneration(productsToGenerate, issue);
    }

    private void runProductGeneration(
            Collection<ProductInformation> productInformationRecords,
            boolean issue) {
        boolean confirm = issue;

        /*
         * Build an audit trail to keep track of the products that have been /
         * will need to be generated.
         */
        synchronized (this.productGenerationAuditManager) {
            final String productGenerationTrackingID = UUID.randomUUID()
                    .toString();
            ProductGenerationAuditor productGenerationAuditor = new ProductGenerationAuditor(
                    issue, productGenerationTrackingID);
            for (ProductInformation productInformation : productInformationRecords) {
                productInformation.setGenerationID(productGenerationTrackingID);
                productGenerationAuditor
                        .addProductToBeGenerated(productInformation);
            }
            this.productGenerationAuditManager.put(productGenerationTrackingID,
                    productGenerationAuditor);
        }

        for (ProductInformation productInformation : productInformationRecords) {
            boolean continueGeneration = this.productManager.generate(
                    productInformation, issue, confirm);
            confirm = false;
            if (continueGeneration == false) {
                /*
                 * Halt product generation, the user indicated that they did not
                 * want to issue the product(s).
                 */
                break;
            }
        }
    }

    @Handler
    public void auditProductGeneration(ProductGenerated generated) {
        ProductGenerationAuditor productGenerationAuditor = null;
        ProductInformation productInformation = generated
                .getProductInformation();
        final String generationID = productInformation.getGenerationID();
        final GeneratedProductList generatedProducts = productInformation
                .getProducts();
        synchronized (this.productGenerationAuditManager) {
            if (this.productGenerationAuditManager.get(generationID)
                    .productGenerated(generatedProducts, productInformation) == false) {
                return;
            }

            productGenerationAuditor = this.productGenerationAuditManager
                    .remove(generationID);
        }

        this.publishGenerationCompletion(productGenerationAuditor);
    }

    @Handler
    public void handleProductGeneratorResult(ProductFailed failed) {
        ProductGenerationAuditor productGenerationAuditor = null;
        ProductInformation productInformation = failed.getProductInformation();
        final String generationID = productInformation.getGenerationID();
        synchronized (this.productGenerationAuditManager) {
            if (this.productGenerationAuditManager.get(generationID)
                    .productGenerationFailure(productInformation) == false) {
                return;
            }

            productGenerationAuditor = this.productGenerationAuditManager
                    .remove(generationID);
        }

        this.publishGenerationCompletion(productGenerationAuditor);
        statusHandler.error("Product Generator "
                + failed.getProductInformation().getProductGeneratorName()
                + " failed.");
    }

    private void publishGenerationCompletion(
            ProductGenerationAuditor productGenerationAuditor) {
        IProductGenerationComplete productGenerationComplete = new ProductGenerationComplete(
                productGenerationAuditor.isIssue(),
                productGenerationAuditor.getGeneratedProducts());
        this.eventBus.publishAsync(productGenerationComplete);
    }

    @Override
    public String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    /**
     * Launch the Staging Dialog if necessary OR return the Generated Products
     * 
     * @param issue
     *            Flag indicating whether or not this is the result of an issue
     *            action.
     * @return
     */
    void generate(boolean issue) {
        if (issue) {
            sessionManager.setIssueOngoing(true);
        } else {
            sessionManager.setPreviewOngoing(true);
        }

        if (productGenerationRequired(issue)) {

            List<String> unsupportedHazards = sessionManager
                    .getProductManager().getUnsupportedHazards();

            Collection<ProductInformation> selectedProducts = sessionManager
                    .getProductManager().getSelectedProducts(issue);

            boolean continueWithGeneration = true;

            if (!unsupportedHazards.isEmpty()) {
                StringBuffer message = new StringBuffer(
                        "Products for the following hazard types are not yet supported: ");
                for (String type : unsupportedHazards) {
                    message.append(type + " ");
                }

                if (!selectedProducts.isEmpty()) {
                    message.append("\nPress Continue to generate products for the supported hazard types.");
                    continueWithGeneration = appBuilder.getContinueCanceller()
                            .getUserAnswerToQuestion("Unsupported HazardTypes",
                                    message.toString());
                } else {
                    appBuilder.getWarner().warnUser("Unsupported HazardTypes",
                            message.toString());
                    continueWithGeneration = false;
                }

            }

            if (continueWithGeneration) {
                generateProducts(issue);
            } else {
                if (issue) {
                    sessionManager.setIssueOngoing(false);
                } else {
                    sessionManager.setPreviewOngoing(false);
                }
            }

        } else {
            appBuilder.showProductStagingView(issue,
                    selectedProductsCache.get(issue));
        }
    }
}
