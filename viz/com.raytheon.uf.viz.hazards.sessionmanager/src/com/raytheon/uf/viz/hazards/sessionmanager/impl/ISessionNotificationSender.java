/**
 * This software was developed and / or modified by Raytheon Company,
 * pursuant to Contract DG133W-05-CQ-1067 with the US Government.
 * 
 * U.S. EXPORT CONTROLLED TECHNICAL DATA
 * This software product contains export-restricted data whose
 * export/transfer/disclosure is restricted by U.S. law. Dissemination
 * to non-U.S. persons whether in the United States or abroad requires
 * an export license or other authorization.
 * 
 * Contractor Name:        Raytheon Company
 * Contractor Address:     6825 Pine Street, Suite 340
 *                         Mail Stop B8
 *                         Omaha, NE 68106
 *                         402.291.0100
 * 
 * See the AWIPS II Master Rights File ("Master Rights File.pdf") for
 * further licensing information.
 **/
package com.raytheon.uf.viz.hazards.sessionmanager.impl;

import java.util.Set;

import com.raytheon.uf.viz.hazards.sessionmanager.ISessionNotification;

/**
 * Interface describing the methods that must be implemented by any class that
 * is to send {@link ISessionNotification} messages.
 * <p>
 * Notifications may be posted using
 * {@link #postNotification(ISessionNotification)}, meaning that they are sent
 * off immediately, or using
 * {@link #postNotificationAsync(ISessionNotification)}, meaning that they are
 * enqueued to be sent off after the method returns.
 * </p>
 * <p>
 * Additionally, any posted via the latter method may be optionally delayed so
 * that they may be merged with other notifications that are being prepared for
 * sending as a batch. This is done by using
 * {@link #startAccumulatingAsyncNotifications()} to indicate that such batching
 * should be begun, and then subsquently using
 * {@link #finishAccumulatingAsyncNotifications()} to indicate that the batching
 * should be completed. When it completes, all batched notifications that
 * accumulated since the first method was called are sent on their way.
 * </p>
 * <p>
 * Some session manager components may wish to be notified of changes made by
 * other such components. This is termed an intra-managerial notification.
 * Components that are to be so notified may register handlers using
 * {@link #registerIntraNotificationHandler(Class, IIntraNotificationHandler)}
 * or {@link #registerIntraNotificationHandler(Set, IIntraNotificationHandler)},
 * and may unregister them using
 * {@link #unregisterIntraNotificationHandler(IIntraNotificationHandler)}.
 * </p>
 * 
 * <pre>
 * 
 * SOFTWARE HISTORY
 * 
 * Date         Ticket#    Engineer     Description
 * ------------ ---------- ------------ --------------------------
 * Jul 10, 2013            bsteffen     Initial creation.
 * Sep 27, 2017   38072    Chris.Golden Added intra-managerial notifications
 *                                      and message batching capability.
 * Oct 23, 2017   21730    Chris.Golden Changed IIntraNotificationHander to make
 *                                      its isSynchronous() method take the
 *                                      notification to be handled, so that a
 *                                      decision about whether to handle it
 *                                      synchronously or not may be properly
 *                                      contextualized.
 * </pre>
 * 
 * @author bsteffen
 * @version 1.0
 */
public interface ISessionNotificationSender {

    // Public Interfaces

    /**
     * Interface describing the methods that must be implemented by a handler of
     * intra-managerial notifications, that is, notifications generated by one
     * manager for which another manager wishes to be notified.
     */
    public interface IIntraNotificationHandler<N extends ISessionNotification> {

        /**
         * Handle the specified notification.
         * 
         * @param notification
         *            Notification to be handled.
         */
        public void handleNotification(N notification);

        /**
         * Determine whether or not this handler should be invoked
         * synchronously, that is, when the notification is posted. The answer
         * to this may be based upon the specified notification, which is to be
         * handled.
         * 
         * @param notification
         *            Notification that is to be handled.
         * @return <code>true</code> if this handler should be invoked
         *         synchronously, <code>false</code> otherwise.
         */
        public boolean isSynchronous(N notification);
    }

    // Public Methods

    /**
     * Register the specified intra-managerial notification handler, that is, a
     * handler created by a manager to listen for notifications being generated
     * by another manager.
     * 
     * @param type
     *            Type of notifications for which to listen.
     * @param handler
     *            Handler for the notifications of this type.
     */
    public <N extends ISessionNotification> void registerIntraNotificationHandler(
            Class<N> type, IIntraNotificationHandler<N> handler);

    /**
     * Register the specified intra-managerial notification handler, that is, a
     * handler created by a manager to listen for notifications being generated
     * by another manager.
     * 
     * @param types
     *            Types of notifications for which to listen.
     * @param handler
     *            Handler for the notifications of this type.
     */
    public <N extends ISessionNotification> void registerIntraNotificationHandler(
            Set<Class<? extends N>> types,
            IIntraNotificationHandler<N> handler);

    /**
     * Unregister the specified intra-managerial notification handler, that is,
     * a handler created by a manager to listen for notifications being
     * generated by another manager.
     * 
     * @param handler
     *            Handler to be unregistered.
     */
    public <N extends ISessionNotification> void unregisterIntraNotificationHandler(
            IIntraNotificationHandler<N> handler);

    /**
     * Post the specified notification immediately (synchronously).
     * 
     * @param notification
     *            Notification to be posted.
     */
    public void postNotification(ISessionNotification notification);

    /**
     * Post the specified notification asynchronously.
     * 
     * @param notification
     *            Notification to be posted.
     */
    public void postNotificationAsync(ISessionNotification notification);

    /**
     * Begin accumulating asynchronous notifications (that is, any notifications
     * posted using {@link #postNotificationAsync(ISessionNotification)} in
     * order to send them all at once later on, merged together wherever
     * possible in order to reduce the number of individual notifications.
     * Calling this method increments a counter; calling
     * {@link #finishAccumulatingAsyncNotifications()} decrements the counter
     * and, if the counter reaches <code>0</code>, posts the accumulated
     * notifications.
     */
    public void startAccumulatingAsyncNotifications();

    /**
     * Decrement the counter that is incremented via
     * {@link #startAccumulatingAsyncNotifications()}, and if this leaves it at
     * <code>0</code>, post any asynchronous notifications that have accumulated
     * by calls to {@link #postNotificationAsync(ISessionNotification)}.
     */
    public void finishAccumulatingAsyncNotifications();
}
