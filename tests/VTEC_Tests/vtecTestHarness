#!/usr/bin/env python

#---------------------------------------------------------------
# TEST HARNESS FOR VTECEngine and VTECIngester
#---------------------------------------------------------------

# This code will have to be modified to work in the Hazard Services environment
# as it doesn't use the bridge.

from VTECEngineWrapper import VTECEngineWrapper
from VTECTableIO import VTECTableIO
import Logger as LS
from Bridge import Bridge

import copy
import calendar
import os
import os.path
import time
import re
import argparse
import TestScript
import collections

# IMPORTANT TO HAVE ROUTINES RUNNING IN GMT0 TIME or the VTECEngine will fail.
os.environ["TZ"] = "GMT0"

# regular expressions for the VTEC and HVTEC lines to 'find' them from the
# test scripts.
VTECre = r'/[OTEX]\.([A-Z]{3})\.([A-Z]{4})\.([A-Z]{2})\.' + \
          r'([WAYSOFN])\.([0-9]{4})\.([0-9]{6})T([0-9]{4})Z\-' + \
          r'([0-9]{6})T([0-9]{4})Z/'
HVTECre = r'/[0-9A-Z]{5}\.[0-3NU]\.[A-Z]{2}\.' + \
          r'[0-9]{6}T[0-9]{4}Z\.' + \
          r'[0-9]{6}T[0-9]{4}Z\.[0-9]{6}T[0-9]{4}Z\.[A-Z][A-Z]/'


# THIS CODE USES THE vtec records directly through the use of the VTECTableIO
# class. The location is defined in the test version of the VTECEngineWrapper.
       
class VTECTestHarness(object):

    def __init__(self, scriptName, scripts):
        '''Constructor for running the vtec tests.

        Keyword Arguments:
        scriptName -- name of the script, used for pretty-printing
        scripts -- list of dictionaries with each dictionary containing
          information about the test including setup and expected results.
        '''
        self._scriptName = scriptName
        self._scripts = scripts
        #self._io = VTECTableIO(DBPATH)        
        self.bridge = Bridge()

    def runTest(self):
        '''Runs the VTEC test.  Returns True/False depending upon success'''

        LS.logVerbose("TEST STARTED:  {script}".format(script=self._scriptName))

        # we clear the hazards table initially
        #self._io.writeVtecRecords([])
        self.bridge.putData('{"dataType":"testVtecRecords", "vtecDicts": []}')
        

        for script in self._scripts:
            calculated = self._runEachIndividualTest(script)
            if calculated:
                expected = script.get('checkStrings', [])
                status = self._checkResults(calculated, expected)
                if not status:
                    LS.logProblem("TEST FAILED:   {script}:{sub}".format(
                      script=self._scriptName, sub=script['name']))
                    return False

        LS.logVerbose("TEST FINISHED: {script}".format(script=self._scriptName))
        return True

    def _createEventDicts(self, script):
        '''creates EventDict records from the test script.

        Keyword Arguments:
        script -- list of dictionaries defining the test case.

        Returns a list of EventDicts (dictionaries)
        '''

        eventDicts = []

        # calculate the grids start time and drt time
        gridsStartTime = self._getIntTime(script["gridsStartTime"])

        geoType = script.get('geoType', 'area')

        # set the default
        base = {'siteID': 'KTBW', 'eventID': 0, 'state': 'issued',
          'geoType': geoType}
        grids = script.get('createGrids', [])
        for gentry in grids:
            try:
                t1, t2, value, zones, other = gentry
            except: 
                t1, t2, value, zones = gentry
                other = None

            # populate the basic eventDict, add the geoIDs
            event = copy.deepcopy(base)
            if geoType == 'area':
                event['ugcs'] = zones
            elif geoType == 'point':
                event['pointID'] = zones[0]

            # hazard type
            event['type'] = value

            # calculate the starting and ending times
            event['startTime'] = (gridsStartTime + t1 * 3600) * 1000  #Millisec
            event['endTime'] = (gridsStartTime + t2 * 3600) * 1000  #Millisec

            # if an optional dictionary is declared in the test case, then
            # extract those values and make them keys in the EventDict.
            # For the hydro times, translate into milliseconds since epoch
            if other:
                for k, v in other.items():
                    # translate hydro times into actual times
                    if k in ['riseAbove', 'crest', 'fallBelow']:
                        v = (gridsStartTime + v * 3600) * 1000 #milliseconds
                    # store the key/value into the EventDict
                    event[k] = v
            eventDicts.append(event)
            
        s = 'EventDicts:\n'
        for evD in eventDicts:
            s += '{d}\n'.format(d=evD)
        LS.logDebug(s)
            
        return eventDicts
       
    def _runEachIndividualTest(self, script):
        '''Runs each individual test.

        Keyword Arguments:
        script -- test script as a dictionary of options.

        Returns a ordered list of segments.  Within each list of
        segments is a list of UGCs, P-VTEC, and H-VTEC codes.
        '''

        LS.logVerbose("**************************************************")
        LS.logVerbose(script['name'])
        LS.logVerbose("**************************************************")

        clear = script.get('clearHazardsTable', 0)
        if clear:
            #self._io.writeVtecRecords([])
            self.bridge.putData('{"dataType":"testVtecRecords", "vtecDicts": []}')
                     
        productType = script.get("productType")
        if not productType:
            return None  # no more to do without a product type

        # create the EventDicts for this test case.
        eventDicts = self._createEventDicts(script)

        # get the time that this is being run
        drtTimeS = script.get('drtTime')
        if not drtTimeS:
            drtTimeS = script['gridsStartTime']
        drtTime = self._getIntTime(drtTimeS)

        # run the calculations
        engine = VTECEngineWrapper(None, productType, 'KTBW', eventDicts,
          creationTime=drtTime * 1000, vtecMode=script['vtecMode'], testHarnessMode=1)

        # get the ordered segments
        segments = engine.engine().getSegments()
        segst = "Segments:\n"
        for geoID, eventID in segments:
            segst += "  GeoID: {gid}  EventID: {eid}\n".format(gid=list(geoID),
              eid=list(eventID))
        LS.logVerbose(segst)

        # get the results and package them up. Each list member is a segment
        # with the next level being the UGCstrings, VTEC strings and HVTEC strs
        results = []
        for seg in segments:
            # handle the geoID string
            ugc = self._makeUGCString(seg) + "-"
            results.append(ugc)

            vstrCalculated = engine.engine().getVTECString(seg)

            slog = ("CALCULATED VTEC for segment GeoID: {gid}  "
              "EventID: {eid}\n{ugc}").format(gid=list(seg[0]),
              eid=list(seg[1]), ugc=ugc)

            for v in vstrCalculated:
                if re.search(VTECre, v):
                    slog += "\nV: {v}".format(v=v)
                    results.append(v)
                elif re.search(HVTECre, v):
                    slog += "\nH: {h}".format(h=v)
                    results.append(v)
            slog += '\n'
            LS.logVerbose(slog)

        # update the vtec records with the calculated records
        issueFlag = 'True' if script['decodeVTEC'] else None
        if issueFlag:
            engine.mergeResults()

        return results

            

    def _checkResults(self, calculated, expected):
        '''Checks the expected and calculated results.

        Keyword Arguments:
        calculated -- calculated list of ugcs, vtec and hvtec strings
        expected -- expected list of ugcs, vtec, and hvtec strings
        '''
        # log the expected and calculated
        msg = "ALLSEGS CALCULATED RESULTS: \n"
        for s in calculated:
            msg += "{s}\n".format(s=s)
        msg += "\nALLSEGS EXPECTED RESULTS:\n"
        for s in expected:
            msg += "{s}\n".format(s=s)
        LS.logVerbose(msg)

        if calculated != expected:
            fmt = ("CALCULATED {word}{num}: {calc}\n"
                  "EXPECTED   {word}{num}: {expect}\n\n")

            # highlight the differences
            results = zip(calculated, expected)
            #errS = "EXPECTED RESULTS NOT OBTAINED:\n{ce}\n".format(ce=msg)
            errS = "EXPECTED RESULTS NOT OBTAINED:\n"

            # problem with common strings
            for idx, (calc, expect) in enumerate(results):
                if calc != expect:
                    errS += fmt.format(word="DIFF", num=idx+1, calc=calc,
                      expect=expect)
                else:
                    errS += fmt.format(word="OKAY", num=idx+1, calc=calc,
                      expect=expect)

            # problem with more expected VTEC than calculated VTEC
            if len(calculated) < len(expected):
                for r in expected[len(calculated):]:
                    errS += fmt.format(word="DIFF", num=idx+len(results),
                      calc=" <missing> ", expect=r)
           

            # problem with more calculated VTEC than expected strings
            else:
                for r in calculated[len(expected):]:
                    errS += fmt.format(word="DIFF", num=idx+len(results),
                      calc=r, expect=" <missing> ")

            LS.logProblem(errS)
            return False

        else:
            return True


    @staticmethod
    def _getIntTime(timeString):
        '''Decodes the YYYYMMDD_HHMM time string into a time_t and returns it'''
        intTime = time.strptime(timeString, "%Y%m%d_%H%M")
        t = calendar.timegm(intTime)
        return t

    @staticmethod
    def _checkLastArrow(inSeq, ugcStr):
        '''Check for inappropriate use of the last arrow and correct it.

        Keyword Arguments:
        inSeq - Counter to indicate whether we are in a sequence of areas.
        ugcStr - input UGC string to possibly correct

        Returns the corrected ugc string.
        '''

        if inSeq == 1:
            # Change the last arrow to - since we only had 2 in the sequence
            # e.g. 062>063  should be   062-063
            arrowIndex = ugcStr.rfind(">")
            if arrowIndex >= 0:
                ugcStr = ugcStr[:arrowIndex] + "-" + ugcStr[arrowIndex+1:]
        return ugcStr

    def _makeUGCString(self, seg):
        '''Constructs a UGC string based on the segment information.

        Keyword Arguments:
        seg -- segment information, such as that from VTECEngine::getSegments(),
           consisting of a tuple of two sets.  The first is a set of
           geoIDs for the segment, the second is a set of eventIDs for
           the segment.

        Returns a string representing the UGC codes, e.g., geoIDs.
        '''

        ugcList = list(copy.deepcopy(seg[0]))
        ugcList.sort()
 
        # if nothing in the list, return empty string
        if len(ugcList) == 0:
            return ""
        elif len(ugcList) == 1:
            return ugcList[0]   # simpliest case

        # Remove any blank UGC lines from the list
        listsize=len(ugcList)
        j=0
        while j < listsize:
            if ugcList[j] == "":
                del ugcList[j]
            j=j+1

        # Set up state variables and process intialize ugcStr with first ugc
        # in ugcList
        inSeq = 0
        ugcStr = ugcList[0]
        curState = ugcStr[0:3]
        lastNum = int(ugcList[0][3:])
        firstNum = 0
        lastUgc = ugcList[0]
    
        # By initializing properly we don't need the first item
        ugcList.remove(ugcList[0])
    
        for ugc in ugcList:
            ugcState = ugc[:3]
            ugcNumStr = ugc[3:]
            num = int(ugcNumStr)
            if ugcState == curState:
                if num == lastNum + 1:
                    if inSeq > 0:
                        # Replace the last ugcNumStr in sequence with the
                        # current ugcNumStr
                        # e.g.   062>063  becomes 062>064
                        ugcStr = ugcStr[:len(ugcStr)-3] + ugcNumStr
                        inSeq += 1
                    else:
                        ugcStr += ">" + ugcNumStr
                        inSeq = 1
                else:  # num != lastNum + 1
                    ugcStr = self._checkLastArrow(inSeq, ugcStr)
                    inSeq = 0  # reset sequence when number not in sequence
                    ugcStr += "-" + ugcNumStr
            else:
                ugcStr = self._checkLastArrow(inSeq, ugcStr)
                ugcStr += "-" + ugc
                curState = ugcState
                inSeq = 0   #reset sequence when switching states
            lastNum = num
            lastUgc = ugc
    
        # May have to clean up last arrow at the end
        ugcStr = self._checkLastArrow(inSeq, ugcStr)
        return ugcStr


def getOpts():
    ''' Option parser for the test harness returning options as namespace.'''
    a = argparse.ArgumentParser(
      description="Runs VTEC tests for VTECEngine and VTECIngester")
    a.add_argument("-d", "--debug", action='store_true',
      help="Enables debugging output")
    a.add_argument("-v", "--verbose", action='store_true',
      help="Enables verbose output")
    a.add_argument("-s", "--stopAfterError", action='store_true',
      help="Stops after error if set, else will continue through other tests")
    a.add_argument("testScripts", nargs=argparse.REMAINDER, 
      help="list of test scripts filenames")
    ns = a.parse_args()

    return ns

# logger modifications
def modifyLogger(options):
    '''Routine to modify logger defaults for this test program.

    Keyword Arguments:
    options -- namespace of options from getOpts()
    '''
    
    level = 25  # allows all warnings and errors
    if options.verbose:
        level = 15
    if options.debug:
        level = 10
    LS.logger.setLevel(level)
    LS.ch.setLevel(level)
    LS.rfh.setLevel(level)
    fmtr = LS.logging.Formatter("**%(levelname)s** - %(message)s")
    LS.ch.setFormatter(fmtr)

# main program
def main():
    '''Main program for testHarness'''

    # do command line processing
    options = getOpts() 

    # modify the logging level for this program
    modifyLogger(options)

    LS.logger.log(75, "VTEC Test Harness Starting")


    # run each script
    errorCount = 0
    for fn in options.testScripts:
        dirname = os.path.dirname(fn)
        basename = os.path.basename(fn)
        base = os.path.splitext(basename)[0]  # without extension
        LS.logger.log(75, "TESTING SCRIPT {f}".format(f=base))

        tnamespace = {}
        try:
            execfile(fn, tnamespace)
        except IOError as e:
            LS.logProblem("ERROR: Test file {f}. {e}".format(f=fn, e=e))
            continue
        except ImportError as e:
            LS.logProblem("ERROR: Test file {f}. {e}".format(f=fn, e=e))
            continue

        base = os.path.splitext(basename)[0]  # without extension
        vth = VTECTestHarness(base, tnamespace['testScript']())
        status = vth.runTest()
        if not status:
            errorCount += 1

        if errorCount and options.stopAfterError:
            break

    word = "ALL PASSED" if not errorCount else "FAILED {n} TESTS".format(n=errorCount)
    LS.logger.log(75, ("VTEC Test Harness Finished -- {w}".format(w=word)))

            
if __name__ == '__main__':
    main()
