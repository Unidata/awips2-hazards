#!/usr/bin/env python

'''
    Description: 
#------------------------------------------------------------------
#  TEST HARNESS FOR VTECEngine and VTECIngester
    
    SOFTWARE HISTORY
    Date         Ticket#    Engineer    Description
    ------------ ---------- ----------- --------------------------
    Dec      2013  2368      Tracy.L.Hansen      Removing use of Bridge
    Feb      2014  2826      dgilling            Modified to support new VTECTableIO class.
    
    @author Mark Mathewson / Tracy.L.Hansen@noaa.gov
    @version 1.0
'''

import copy
import calendar
import os
import time
import re
import argparse
import TestScript
import collections
import datetime
import inspect
import glob
import traceback

# Thrift client interface to localization files in EDEX is broken for now,
# so force localization file access from the code base in order to get
# the VTEC tests to function.
os.environ["LOCALIZATION_DATA_SOURCE"] = "CODE"

# use updateSysPath module in ../python_Tests/ to bootstrap python paths
import sys
sourcePath = os.path.abspath(inspect.getsourcefile(lambda _: None))
scriptsDirList = sourcePath.split("/")[:-1]+["vtecTestScripts"]
pythonTestDirList = sourcePath.split("/")[:-2]+["python_Tests"]
scriptsDir = os.path.join("/", *scriptsDirList)
pythonTestDir = os.path.join("/", *pythonTestDirList)
sys.path.append(pythonTestDir)
from updateSysPath import updateSysPath
updateSysPath(fromSibling="edexOsgi/com.raytheon.uf.tools.cli/impl/src")

import VTECTableIO
from VTECEngineWrapper import VTECEngineWrapper
import Logger as LS
from HazardEvent import HazardEvent

# IMPORTANT TO HAVE ROUTINES RUNNING IN GMT0 TIME or the VTECEngine will fail.
os.environ["TZ"] = "GMT0"

# regular expressions for the VTEC and HVTEC lines to 'find' them from the
# test scripts.
VTECre = r'/[OTEX]\.([A-Z]{3})\.([A-Z]{4})\.([A-Z]{2})\.' + \
          r'([WAYSOFN])\.([0-9]{4})\.([0-9]{6})T([0-9]{4})Z\-' + \
          r'([0-9]{6})T([0-9]{4})Z/'
HVTECre = r'/[0-9A-Z]{5}\.[0-3NU]\.[A-Z]{2}\.' + \
          r'[0-9]{6}T[0-9]{4}Z\.' + \
          r'[0-9]{6}T[0-9]{4}Z\.[0-9]{6}T[0-9]{4}Z\.[A-Z][A-Z]/'

        
class VTECTestHarness(object):

    def __init__(self, scriptName, scripts):
        '''Constructor for running the vtec tests.

        Keyword Arguments:
        scriptName -- name of the script, used for pretty-printing
        scripts -- list of dictionaries with each dictionary containing
          information about the test including setup and expected results.
        '''
        self._scriptName = scriptName
        self._scripts = scripts
        self._io = VTECTableIO.getInstance("KTBW", True, True)
        self._eventNum = 0       

    def runTest(self):
        '''Runs the VTEC test.  Returns True/False depending upon success'''

        LS.logVerbose("TEST STARTED:  {script}".format(script=self._scriptName))

        # we clear the hazards table initially
        self._io.clearVtecTable()
        
        for script in self._scripts:
            calculated = self._runEachIndividualTest(script)
            if calculated:
                expected = script.get('checkStrings', [])
                status = self._checkResults(calculated, expected)
                if not status:
                    LS.logProblem("TEST FAILED:   {script}:{sub}".format(
                      script=self._scriptName, sub=script['name']))
                    return False

        LS.logVerbose("TEST FINISHED: {script}".format(script=self._scriptName))
        return True

    def _createHazardEvents(self, script):
        '''creates pure Python HazardEvents from the test script.

        Keyword Arguments:
        script -- list of dictionaries defining the test case.

        Returns a list of HazardEvents
        '''

        hazardEvents = []

        # calculate the grids start time and drt time
        gridsStartTime = self._getIntTime(script["gridsStartTime"])

        geoType = script.get('geoType', 'area')

        # set the default
        base = {'siteID4': 'KTBW', 'geoType': geoType}
        grids = script.get('createGrids', [])
        for gentry in grids:
            try:
                t1, t2, value, zones, other = gentry
            except: 
                t1, t2, value, zones = gentry
                other = None

            # populate the basic HazardEvent, add the geoIDs
            event = HazardEvent()
            event.setHazardAttributes({})
            event.setEventID('0')
            event.setStatus("ISSUED")
            attributes = copy.deepcopy(base)
            if geoType == 'area':
                attributes['ugcs'] = zones
            elif geoType == 'point':
                attributes['pointID'] = zones[0]

            # hazard type
            parts = value.split(".")
            event.setPhenomenon(parts[0])
            event.setSignificance(parts[1])
            if len(parts) > 2:
                event.setSubType(parts[2])

            # calculate the starting and ending times
            event.setStartTime(datetime.datetime.fromtimestamp(gridsStartTime + t1 * 3600))  # sec
            event.setEndTime(datetime.datetime.fromtimestamp(gridsStartTime + t2 * 3600))  # sec
            
            # if an optional dictionary is declared in the test case, then
            # extract those values and make them keys in the EventDict.
            # For the hydro times, translate into milliseconds since epoch
            if other:
                for k, v in other.items():
                    # translate hydro times into actual times
                    if k in ['riseAbove', 'crest', 'fallBelow']:
                        v = (gridsStartTime + v * 3600) * 1000 #milliseconds
                    # store the key/value into the HazardEvent
                    if k == "eventID":
                        event.setEventID(str(v))
                    elif k== 'status':
                        event.setStatus(v.upper())
                    else:
                        attributes[k] = v
            event.addHazardAttributes(attributes)
            hazardEvents.append(event)
            
        s = 'HazardEvents:\n'
        for he in hazardEvents:
            s += '{d}\n'.format(d=he)
        LS.logDebug(s)
            
        return hazardEvents
       
    def _runEachIndividualTest(self, script):
        '''Runs each individual test.

        Keyword Arguments:
        script -- test script as a dictionary of options.

        Returns a ordered list of segments.  Within each list of
        segments is a list of UGCs, P-VTEC, and H-VTEC codes.
        '''

        LS.logVerbose("**************************************************")
        LS.logVerbose(script['name'])
        LS.logVerbose("**************************************************")

        clear = script.get('clearHazardsTable', 0)
        if clear:
            self._io.clearVtecTable()
                     
        productType = script.get("productType")
        if not productType:
            return None  # no more to do without a product type

        # create the HazardEvents for this test case.
        hazardEvents = self._createHazardEvents(script)
        #print "Harness\n", hazardEvents

        # get the time that this is being run
        drtTimeS = script.get('drtTime')
        if not drtTimeS:
            drtTimeS = script['gridsStartTime']
        drtTime = self._getIntTime(drtTimeS)

        # run the calculations
        productGeneratorName = None
        wrapper = VTECEngineWrapper(None, productType, 'KTBW', hazardEvents,
          issueTime=drtTime, vtecMode=script['vtecMode'], operationalMode=False, 
          testHarnessMode=1, productGeneratorName = productGeneratorName)

        # get the ordered segments
        segments = wrapper.engine().getSegments()
        segst = "Segments:\n"
        for geoID, eventID in segments:
            segst += "  GeoID: {gid}  EventID: {eid}\n".format(gid=list(geoID),
              eid=list(eventID))
        LS.logVerbose(segst)

        # get the results and package them up. Each list member is a segment
        # with the next level being the UGCstrings, VTEC strings and HVTEC strs
        results = []
        for seg in segments:
            # handle the geoID string
            ugc = self._makeUGCString(seg) + "-"
            results.append(ugc)

            vstrCalculated = wrapper.engine().getVTECString(seg)

            slog = ("CALCULATED VTEC for segment GeoID: {gid}  "
              "EventID: {eid}\n{ugc}").format(gid=list(seg[0]),
              eid=list(seg[1]), ugc=ugc)

            for v in vstrCalculated:
                if re.search(VTECre, v):
                    slog += "\nV: {v}".format(v=v)
                    results.append(v)
                elif re.search(HVTECre, v):
                    slog += "\nH: {h}".format(h=v)
                    results.append(v)
            slog += '\n'
            LS.logVerbose(slog)

        # update the vtec records with the calculated records
        issueFlag = 'True' if script['decodeVTEC'] else None
        if issueFlag:
            wrapper.mergeResults()

        return results

            

    def _checkResults(self, calculated, expected):
        '''Checks the expected and calculated results.

        Keyword Arguments:
        calculated -- calculated list of ugcs, vtec and hvtec strings
        expected -- expected list of ugcs, vtec, and hvtec strings
        '''
        # log the expected and calculated
        msg = "ALLSEGS CALCULATED RESULTS: \n"
        for s in calculated:
            msg += "{s}\n".format(s=s)
        msg += "\nALLSEGS EXPECTED RESULTS:\n"
        for s in expected:
            msg += "{s}\n".format(s=s)
        LS.logVerbose(msg)

        if calculated != expected:
            fmt = ("CALCULATED {word}{num}: {calc}\n"
                  "EXPECTED   {word}{num}: {expect}\n\n")

            # highlight the differences
            results = zip(calculated, expected)
            #errS = "EXPECTED RESULTS NOT OBTAINED:\n{ce}\n".format(ce=msg)
            errS = "EXPECTED RESULTS NOT OBTAINED:\n"

            # problem with common strings
            for idx, (calc, expect) in enumerate(results):
                if calc != expect:
                    errS += fmt.format(word="DIFF", num=idx+1, calc=calc,
                      expect=expect)
                else:
                    errS += fmt.format(word="OKAY", num=idx+1, calc=calc,
                      expect=expect)

            # problem with more expected VTEC than calculated VTEC
            if len(calculated) < len(expected):
                for r in expected[len(calculated):]:
                    errS += fmt.format(word="DIFF", num=idx+len(results),
                      calc=" <missing> ", expect=r)
           

            # problem with more calculated VTEC than expected strings
            else:
                for r in calculated[len(expected):]:
                    errS += fmt.format(word="DIFF", num=idx+len(results),
                      calc=r, expect=" <missing> ")

            LS.logProblem(errS)
            return False

        else:
            return True


    @staticmethod
    def _getIntTime(timeString):
        '''Decodes the YYYYMMDD_HHMM time string into a time_t and returns it'''
        intTime = time.strptime(timeString, "%Y%m%d_%H%M")
        t = calendar.timegm(intTime)
        return t

    @staticmethod
    def _checkLastArrow(inSeq, ugcStr):
        '''Check for inappropriate use of the last arrow and correct it.

        Keyword Arguments:
        inSeq - Counter to indicate whether we are in a sequence of areas.
        ugcStr - input UGC string to possibly correct

        Returns the corrected ugc string.
        '''

        if inSeq == 1:
            # Change the last arrow to - since we only had 2 in the sequence
            # e.g. 062>063  should be   062-063
            arrowIndex = ugcStr.rfind(">")
            if arrowIndex >= 0:
                ugcStr = ugcStr[:arrowIndex] + "-" + ugcStr[arrowIndex+1:]
        return ugcStr

    def _makeUGCString(self, seg):
        '''Constructs a UGC string based on the segment information.

        Keyword Arguments:
        seg -- segment information, such as that from VTECEngine::getSegments(),
           consisting of a tuple of two sets.  The first is a set of
           geoIDs for the segment, the second is a set of eventIDs for
           the segment.

        Returns a string representing the UGC codes, e.g., geoIDs.
        '''

        ugcList = list(copy.deepcopy(seg[0]))
        ugcList.sort()
 
        # if nothing in the list, return empty string
        if len(ugcList) == 0:
            return ""
        elif len(ugcList) == 1:
            return ugcList[0]   # simpliest case

        # Remove any blank UGC lines from the list
        listsize=len(ugcList)
        j=0
        while j < listsize:
            if ugcList[j] == "":
                del ugcList[j]
            j=j+1

        # Set up state variables and process intialize ugcStr with first ugc
        # in ugcList
        inSeq = 0
        ugcStr = ugcList[0]
        curState = ugcStr[0:3]
        lastNum = int(ugcList[0][3:])
        firstNum = 0
        lastUgc = ugcList[0]
    
        # By initializing properly we don't need the first item
        ugcList.remove(ugcList[0])
    
        for ugc in ugcList:
            ugcState = ugc[:3]
            ugcNumStr = ugc[3:]
            num = int(ugcNumStr)
            if ugcState == curState:
                if num == lastNum + 1:
                    if inSeq > 0:
                        # Replace the last ugcNumStr in sequence with the
                        # current ugcNumStr
                        # e.g.   062>063  becomes 062>064
                        ugcStr = ugcStr[:len(ugcStr)-3] + ugcNumStr
                        inSeq += 1
                    else:
                        ugcStr += ">" + ugcNumStr
                        inSeq = 1
                else:  # num != lastNum + 1
                    ugcStr = self._checkLastArrow(inSeq, ugcStr)
                    inSeq = 0  # reset sequence when number not in sequence
                    ugcStr += "-" + ugcNumStr
            else:
                ugcStr = self._checkLastArrow(inSeq, ugcStr)
                ugcStr += "-" + ugc
                curState = ugcState
                inSeq = 0   #reset sequence when switching states
            lastNum = num
            lastUgc = ugc
    
        # May have to clean up last arrow at the end
        ugcStr = self._checkLastArrow(inSeq, ugcStr)
        return ugcStr


def getOpts():
    ''' Option parser for the test harness returning options as namespace.'''
    a = argparse.ArgumentParser(
      description="Runs VTEC tests for VTECEngine and VTECIngester")
    a.add_argument("-d", "--debug", action='store_true',
      help="Enables debugging output")
    a.add_argument("-v", "--verbose", action='store_true',
      help="Enables verbose output")
    a.add_argument("-s", "--stopAfterError", action='store_true',
      help="Stops after error if set, else will continue through other tests")
    a.add_argument("testScripts", nargs=argparse.REMAINDER, 
      help="list of test scripts filenames")
    ns = a.parse_args()

    return ns

# logger modifications
def modifyLogger(options):
    '''Routine to modify logger defaults for this test program.

    Keyword Arguments:
    options -- namespace of options from getOpts()
    '''
    
    level = 25  # allows all warnings and errors
    if options.verbose:
        level = 15
    if options.debug:
        level = 10
    LS.logger.setLevel(level)
    LS.ch.setLevel(level)
    LS.rfh.setLevel(level)
    fmtr = LS.logging.Formatter("**%(levelname)s** - %(message)s")
    LS.ch.setFormatter(fmtr)

# main program
def main():
    '''Main program for testHarness'''

    # do command line processing
    options = getOpts() 

    # modify the logging level for this program
    modifyLogger(options)

    LS.logger.log(75, "VTEC Test Harness Starting")

    # If no file arguments provided, just use all the *.py files in
    # the vtecTestScripts/ subdirectory.
    if not options.testScripts:
        options.testScripts = glob.glob(os.path.join(scriptsDir, "*.py"))

    # run each script
    errorCount = 0
    for fn in options.testScripts:
        dirname = os.path.dirname(fn)
        
        # No directory specified, assume vtecTestScripts/ subdirectory.
        if dirname == "" :
            dirname = scriptsDir
            fn = os.path.join(scriptsDir, fn)

        basename = os.path.basename(fn)
        base = os.path.splitext(basename)[0]  # without extension
        LS.logger.log(75, "TESTING SCRIPT {f}".format(f=base))

        tnamespace = {}
        try:
            execfile(fn, tnamespace)
        except IOError as e:
            LS.logProblem("ERROR: Test file {f}. {e}".format(f=fn, e=e))
            continue
        except ImportError as e:
            LS.logProblem("ERROR: Test file {f}. {e}".format(f=fn, e=e))
            continue

        base = os.path.splitext(basename)[0]  # without extension
        vth = VTECTestHarness(base, tnamespace['testScript']())
        try:
             status = vth.runTest()
        except Exception as s:
             status = False
             print "EXCEPTION: ", s 
             traceback.print_exc()                   
        if not status:
            errorCount += 1

        if errorCount and options.stopAfterError:
            break

    word = "ALL PASSED" if not errorCount else "FAILED {n} TESTS".format(n=errorCount)
    LS.logger.log(75, ("VTEC Test Harness Finished -- {w}".format(w=word)))

if __name__ == '__main__':
    main()
